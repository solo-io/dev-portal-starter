{
  "version": 3,
  "sources": ["../../../swr/mutation/dist/index.mjs"],
  "sourcesContent": ["import { useRef, useCallback } from 'react';\nimport useSWR, { useSWRConfig } from 'swr';\nimport { withMiddleware, useStateWithDeps, UNDEFINED, serialize, mergeObjects, getTimestamp, useIsomorphicLayoutEffect } from 'swr/_internal';\n\nconst mutation = ()=>{\n    return (key, fetcher, config = {})=>{\n        const { mutate  } = useSWRConfig();\n        const keyRef = useRef(key);\n        const fetcherRef = useRef(fetcher);\n        const configRef = useRef(config);\n        // Ditch all mutation results that happened earlier than this timestamp.\n        const ditchMutationsUntilRef = useRef(0);\n        const [stateRef, stateDependencies, setState] = useStateWithDeps({\n            data: UNDEFINED,\n            error: UNDEFINED,\n            isMutating: false\n        });\n        const currentState = stateRef.current;\n        const trigger = useCallback(async (arg, opts)=>{\n            const [serializedKey, resolvedKey] = serialize(keyRef.current);\n            if (!fetcherRef.current) {\n                throw new Error('Can’t trigger the mutation: missing fetcher.');\n            }\n            if (!serializedKey) {\n                throw new Error('Can’t trigger the mutation: missing key.');\n            }\n            // Disable cache population by default.\n            const options = mergeObjects(mergeObjects({\n                populateCache: false,\n                throwOnError: true\n            }, configRef.current), opts);\n            // Trigger a mutation, and also track the timestamp. Any mutation that happened\n            // earlier this timestamp should be ignored.\n            const mutationStartedAt = getTimestamp();\n            ditchMutationsUntilRef.current = mutationStartedAt;\n            setState({\n                isMutating: true\n            });\n            try {\n                const data = await mutate(serializedKey, fetcherRef.current(resolvedKey, {\n                    arg\n                }), // We must throw the error here so we can catch and update the states.\n                mergeObjects(options, {\n                    throwOnError: true\n                }));\n                // If it's reset after the mutation, we don't broadcast any state change.\n                if (ditchMutationsUntilRef.current <= mutationStartedAt) {\n                    setState({\n                        data,\n                        isMutating: false,\n                        error: undefined\n                    });\n                    options.onSuccess == null ? void 0 : options.onSuccess(data, serializedKey, options);\n                }\n                return data;\n            } catch (error) {\n                // If it's reset after the mutation, we don't broadcast any state change\n                // or throw because it's discarded.\n                if (ditchMutationsUntilRef.current <= mutationStartedAt) {\n                    setState({\n                        error: error,\n                        isMutating: false\n                    });\n                    options.onError == null ? void 0 : options.onError(error, serializedKey, options);\n                    if (options.throwOnError) {\n                        throw error;\n                    }\n                }\n            }\n        }, // eslint-disable-next-line react-hooks/exhaustive-deps\n        []);\n        const reset = useCallback(()=>{\n            ditchMutationsUntilRef.current = getTimestamp();\n            setState({\n                data: UNDEFINED,\n                error: UNDEFINED,\n                isMutating: false\n            });\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }, []);\n        useIsomorphicLayoutEffect(()=>{\n            keyRef.current = key;\n            fetcherRef.current = fetcher;\n            configRef.current = config;\n        });\n        // We don't return `mutate` here as it can be pretty confusing (e.g. people\n        // calling `mutate` but they actually mean `trigger`).\n        // And also, `mutate` relies on the useSWR hook to exist too.\n        return {\n            trigger,\n            reset,\n            get data () {\n                stateDependencies.data = true;\n                return currentState.data;\n            },\n            get error () {\n                stateDependencies.error = true;\n                return currentState.error;\n            },\n            get isMutating () {\n                stateDependencies.isMutating = true;\n                return currentState.isMutating;\n            }\n        };\n    };\n};\n/**\n * A hook to define and manually trigger remote mutations like POST, PUT, DELETE and PATCH use cases.\n *\n * @link https://swr.vercel.app/docs/mutation\n * @example\n * ```jsx\n * import useSWRMutation from 'swr/mutation'\n *\n * const {\n *   data,\n *   error,\n *   trigger,\n *   reset,\n *   isMutating\n * } = useSWRMutation(key, fetcher, options?)\n * ```\n */ var index = withMiddleware(useSWR, mutation);\n\nexport { index as default };\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;AAAA,mBAAoC;AAIpC,IAAM,WAAW,MAAI;AACjB,SAAO,CAAC,KAAK,SAAS,SAAS,CAAC,MAAI;AAChC,UAAM,EAAE,OAAQ,IAAI,aAAa;AACjC,UAAM,aAAS,qBAAO,GAAG;AACzB,UAAM,iBAAa,qBAAO,OAAO;AACjC,UAAM,gBAAY,qBAAO,MAAM;AAE/B,UAAM,6BAAyB,qBAAO,CAAC;AACvC,UAAM,CAAC,UAAU,mBAAmB,QAAQ,IAAI,iBAAiB;AAAA,MAC7D,MAAM;AAAA,MACN,OAAO;AAAA,MACP,YAAY;AAAA,IAChB,CAAC;AACD,UAAM,eAAe,SAAS;AAC9B,UAAM,cAAU;AAAA,MAAY,OAAO,KAAK,SAAO;AAC3C,cAAM,CAAC,eAAe,WAAW,IAAI,UAAU,OAAO,OAAO;AAC7D,YAAI,CAAC,WAAW,SAAS;AACrB,gBAAM,IAAI,MAAM,8CAA8C;AAAA,QAClE;AACA,YAAI,CAAC,eAAe;AAChB,gBAAM,IAAI,MAAM,0CAA0C;AAAA,QAC9D;AAEA,cAAM,UAAU,aAAa,aAAa;AAAA,UACtC,eAAe;AAAA,UACf,cAAc;AAAA,QAClB,GAAG,UAAU,OAAO,GAAG,IAAI;AAG3B,cAAM,oBAAoB,aAAa;AACvC,+BAAuB,UAAU;AACjC,iBAAS;AAAA,UACL,YAAY;AAAA,QAChB,CAAC;AACD,YAAI;AACA,gBAAM,OAAO,MAAM;AAAA,YAAO;AAAA,YAAe,WAAW,QAAQ,aAAa;AAAA,cACrE;AAAA,YACJ,CAAC;AAAA;AAAA,YACD,aAAa,SAAS;AAAA,cAClB,cAAc;AAAA,YAClB,CAAC;AAAA,UAAC;AAEF,cAAI,uBAAuB,WAAW,mBAAmB;AACrD,qBAAS;AAAA,cACL;AAAA,cACA,YAAY;AAAA,cACZ,OAAO;AAAA,YACX,CAAC;AACD,oBAAQ,aAAa,OAAO,SAAS,QAAQ,UAAU,MAAM,eAAe,OAAO;AAAA,UACvF;AACA,iBAAO;AAAA,QACX,SAAS,OAAP;AAGE,cAAI,uBAAuB,WAAW,mBAAmB;AACrD,qBAAS;AAAA,cACL;AAAA,cACA,YAAY;AAAA,YAChB,CAAC;AACD,oBAAQ,WAAW,OAAO,SAAS,QAAQ,QAAQ,OAAO,eAAe,OAAO;AAChF,gBAAI,QAAQ,cAAc;AACtB,oBAAM;AAAA,YACV;AAAA,UACJ;AAAA,QACJ;AAAA,MACJ;AAAA;AAAA,MACA,CAAC;AAAA,IAAC;AACF,UAAM,YAAQ,0BAAY,MAAI;AAC1B,6BAAuB,UAAU,aAAa;AAC9C,eAAS;AAAA,QACL,MAAM;AAAA,QACN,OAAO;AAAA,QACP,YAAY;AAAA,MAChB,CAAC;AAAA,IAEL,GAAG,CAAC,CAAC;AACL,8BAA0B,MAAI;AAC1B,aAAO,UAAU;AACjB,iBAAW,UAAU;AACrB,gBAAU,UAAU;AAAA,IACxB,CAAC;AAID,WAAO;AAAA,MACH;AAAA,MACA;AAAA,MACA,IAAI,OAAQ;AACR,0BAAkB,OAAO;AACzB,eAAO,aAAa;AAAA,MACxB;AAAA,MACA,IAAI,QAAS;AACT,0BAAkB,QAAQ;AAC1B,eAAO,aAAa;AAAA,MACxB;AAAA,MACA,IAAI,aAAc;AACd,0BAAkB,aAAa;AAC/B,eAAO,aAAa;AAAA,MACxB;AAAA,IACJ;AAAA,EACJ;AACJ;AAiBI,IAAI,QAAQ,eAAe,QAAQ,QAAQ;",
  "names": []
}
